////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <Network/Socket.h>
#include <System/Error.h>

#ifdef _MSC_VER
    #pragma warning(disable : 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

////////////////////////////////////////////////////////////
/// Connect to another computer on a specified port
////////////////////////////////////////////////////////////
enum SocketStatus SocketConnect(struct SocketData * Socket, unsigned short Port, char* HostAddress, float Timeout)
{
	struct sockaddr_in	SockAddr;
	enum SocketStatus	Status;
	struct timeval		Time;

    // Use the given socket descriptor, or get a new one
	Socket->Type = socket(PF_INET, SOCK_STREAM, 0);
	Socket->IsBlocking = true;

	// Setup default options
	if (SocketIsValid(Socket))
	{
		// To avoid the "Address already in use" error message when trying to bind to the same port
		int Option = true;
		if (setsockopt(Socket->Type, SOL_SOCKET, SO_REUSEADDR, (char*)(&Option), sizeof(Option)) == -1)
		{
			MessageError("SocketCreate", "Failed to set socket option \"SO_REUSEADDR\" ; binding to a same port may fail if too fast.");
		}

		// Disable the Nagle algorithm (ie. removes buffering of TCP packets)
		if (setsockopt(Socket->Type, IPPROTO_TCP, TCP_NODELAY, (char*)(&Option), sizeof(Option)) == -1)
		{
			MessageError("SocketCreate", "Failed to set socket option \"TCP_NODELAY\" ; all your TCP packets will be buffered.");
		}

		// Set blocking by default (should always be the case anyway)
		SocketHelperSetBlocking(Socket->Type, true);
		Socket->IsBlocking = true;
	}

    // Build the host address
    memset(SockAddr.sin_zero, 0, sizeof(SockAddr.sin_zero));
    SockAddr.sin_family      = AF_INET;
    SockAddr.sin_port        = htons(Port);
    SockAddr.sin_addr.s_addr = inet_addr(HostAddress);

    if (Timeout <= 0)
    {
        //  We're not using a timeout : just try to connect
        if (connect(Socket->Type, (struct sockaddr*)(&SockAddr), sizeof(SockAddr)) == -1)
        {
            // Failed to connect
            return SocketHelperGetErrorStatus();
        }

        // Connection succeeded
        return Done;
    }
    else
    {
        // We're using a timeout : we'll need a few tricks to make it work

        // Save the previous blocking state
        bool IsBlocking = Socket->IsBlocking;

        // Switch to non-blocking to enable our connection timeout
        if (IsBlocking)
        {
			SocketHelperSetBlocking(Socket->Type, true);
			Socket->IsBlocking = true;
        }

        // Try to connect to host
        if (connect(Socket->Type, (struct sockaddr*)(&SockAddr), sizeof(SockAddr)) >= 0)
        {
            // We got instantly connected! (it may no happen a lot...)
            return Done;
        }

        // Get the error status
        Status = SocketHelperGetErrorStatus();

        // If we were in non-blocking mode, return immediatly
        if (!IsBlocking)
            return Status;

        // Otherwise, wait until something happens to our socket (success, timeout or error)
        if (Status == NotReady)
        {
            // Setup the selector
            fd_set Selector;
            FD_ZERO(&Selector);
            FD_SET(Socket->Type, &Selector);

            // Setup the timeout
            Time.tv_sec  = (long)(Timeout);
            Time.tv_usec = ((long)(Timeout * 1000) % 1000) * 1000;

            // Wait for something to write on our socket (would mean the connection has been accepted)
            if (select((int)(Socket->Type + 1), NULL, &Selector, NULL, &Time) > 0)
            {
                // Connection succeeded
                Status = Done;
            }
            else
            {
                // Failed to connect before timeout is over
                Status = SocketHelperGetErrorStatus();
            }
        }

        // Switch back to blocking mode
		SocketHelperSetBlocking(Socket->Type, true);
		Socket->IsBlocking = true;

        return Status;
    }
}


////////////////////////////////////////////////////////////
/// Listen to a specified port for incoming data or connections
////////////////////////////////////////////////////////////
bool SocketListenPort(struct SocketData * Socket, unsigned short Port)
{
	struct sockaddr_in SockAddr;

    // Make sure our socket is valid
    if (!SocketIsValid(Socket))
    {
		// Use the given socket descriptor, or get a new one
		Socket->Type = socket(PF_INET, SOCK_STREAM, 0);
		Socket->IsBlocking = true;

		// Setup default options
		if (SocketIsValid(Socket))
		{
			// To avoid the "Address already in use" error message when trying to bind to the same port
			int Option = true;
			if (setsockopt(Socket->Type, SOL_SOCKET, SO_REUSEADDR, (char*)(&Option), sizeof(Option)) == -1)
			{
				MessageError("SocketCreate", "Failed to set socket option \"SO_REUSEADDR\" ; binding to a same port may fail if too fast.");
			}

			// Disable the Nagle algorithm (ie. removes buffering of TCP packets)
			if (setsockopt(Socket->Type, IPPROTO_TCP, TCP_NODELAY, (char*)(&Option), sizeof(Option)) == -1)
			{
				MessageError("SocketCreate", "Failed to set socket option \"TCP_NODELAY\" ; all your TCP packets will be buffered.");
			}

			// Set blocking by default (should always be the case anyway)
			SocketHelperSetBlocking(Socket->Type, true);
			Socket->IsBlocking = true;
		}
    }

    // Build the address
    memset(SockAddr.sin_zero, 0, sizeof(SockAddr.sin_zero));
    SockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    SockAddr.sin_family      = AF_INET;
    SockAddr.sin_port        = htons(Port);

    // Bind the socket to the specified port
    if (bind(Socket->Type, (struct sockaddr*)(&SockAddr), sizeof(SockAddr)) == -1)
    {
        // Not likely to happen, but...
        MessageError("SocketListenPort", "Failed to bind socket to port %d.", Port);
        return false;
    }

    // Listen to the bound port
    if (listen(Socket->Type, 0) == -1)
    {
        // Socket is deaf..
        MessageError("SocketListenPort", "Failed to listen to port %d.", Port);
        return false;
    }

    return true;
}


////////////////////////////////////////////////////////////
/// Wait for a connection (must be listening to a port).
/// This function will block if the socket is blocking
////////////////////////////////////////////////////////////
enum SocketStatus SocketAccept(struct SocketData * SocketListener, struct SocketData * Connected)
{
    // Address that will be filled with client informations
    struct sockaddr_in ClientAddress;
    SocketLengthType Length = sizeof(ClientAddress);

    // Accept a new connection
    Connected->Type = (SocketType)accept(SocketListener->Type, (struct sockaddr*)(&ClientAddress), &Length);

    // Check errors
    if (!SocketIsValid(Connected))
    {
        if (Connected->Adress)
            Connected->Adress = NULL;

        return SocketHelperGetErrorStatus();
    }

    // Fill address if requested
    if (Connected->Adress)
        Connected->Adress = inet_ntoa(ClientAddress.sin_addr);

    return Done;
}


////////////////////////////////////////////////////////////
/// Send an array of bytes to the host (must be connected first)
////////////////////////////////////////////////////////////
enum SocketStatus SocketSend(struct SocketData * Socket, Int8 * Data, Int32 Size)
{
    // First check that socket is valid
    if (!SocketIsValid(Socket))
        return Error;

    // Check parameters
    if (Data && Size)
    {
        // Loop until every byte has been sent
        int Sent = 0, Length = 0;
        for (Length = 0; Length < Size; Length += Sent)
        {
            // Send a chunk of data
            Sent = send(Socket->Type, (char*)(Data + Length), (Size - Length), 0);

            // Check if an error occured
            if (Sent <= 0)
                return SocketHelperGetErrorStatus();
        }

        return Done;
    }
    else
    {
        // Error...
        MessageError("SocketSend", "Cannot send data over the network (invalid parameters).");
        return Error;
    }
}


////////////////////////////////////////////////////////////
/// Receive an array of bytes from the host (must be connected first).
/// This function will block if the socket is blocking
////////////////////////////////////////////////////////////
enum SocketStatus SocketReceive(struct SocketData * Socket, Int8 * Data, Int32 MaxSize, Int32* SizeReceived)
{
    // First clear the size received
    *SizeReceived = 0;

    // Check that socket is valid
    if (!SocketIsValid(Socket))
        return Error;

    // Check parameters
    if (Data && MaxSize)
    {
        // Receive a chunk of bytes
        Int32 Received = recv(Socket->Type, (char*)(Data), (Int32)(MaxSize), 0);

        // Check the number of bytes received
        if (Received > 0)
        {
            *SizeReceived = Received;
            return Done;
        }
        else if (Received == 0)
        {
            return Disconnected;
        }
        else
        {
            return SocketHelperGetErrorStatus();
        }
    }
    else
    {
        // Error...
        MessageError("SocketReceive", "Cannot receive data from the network (invalid parameters).");
        return Error;
    }
}


////////////////////////////////////////////////////////////
/// Close the socket
////////////////////////////////////////////////////////////
bool SocketClose(struct SocketData * Socket)
{
    if (SocketIsValid(Socket))
    {
        if (!SocketHelperClose(Socket->Type))
        {
            MessageError("SocketClose", "Failed to close socket.");
            return false;
        }

        Socket->Type = InvalidSocket();
    }

    Socket->IsBlocking = true;

    return true;
}


////////////////////////////////////////////////////////////
/// Check if the socket is in a valid state ; this function
/// can be called any time to check if the socket is OK
////////////////////////////////////////////////////////////
bool SocketIsValid(struct SocketData * Socket)
{
    return (Socket->Type != InvalidSocket());
}
